/**

Нужная сумма
Ограничение времени	0.05 секунд
Ограничение памяти	5Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Даны два строго возрастающих массива целых чисел A[0..n) и B[0..m) и число k. Найти количество 
таких пар индексов (i, j), что A[i] + B[j] = k. Время работы O(n + m). n, m ≤ 100000.

Указание. Обходите массив B от конца к началу.

Пример
Ввод	
4
-5 0 3 18
5
-10 -2 4 7 12
7

Вывод
3


ID Решения: 12399067
**/

/**
Время работы: О(len1 + len2)
Доп. память:  T(1)
**/


#include <iostream>

long sumsEqualsTo(const int* series_1, const int* series_2, long len1, long len2, long k) {
	long count = 0;
	long i = 0; 
	long j = len2 - 1;
	long step_counter = 0;
	
	// обход массивов, причем, первый оходится слева направо, а второй - справа на лево
	while ( step_counter < len1 + len2 ) {
		if ( series_1[i] + series_2[j] == k ) {
			count++;

			if ((i == len1 - 1) && (j == 0)) { // выход из цикла, если оба массива пройдены
				break;
			}
			
			if (i < len1 - 1) { // перейти на следующий элемент, если текущий не последний
				i++;
			}
			if (j > 0) { // перейти на следующий элемент, если текущий не нулевой
				j--;
			}
		} else if (series_1[i] + series_2[j] < k) { // если сумма элементов меньше k, то необходимо сумму увеличить (это возможно только взятием следующего элемента из первого массива)
			if (i < len1 - 1) { // перейти на следующий элемент, если текущий не последний
				i++;				
			} else if (j > 0) { // перейти на следующий элемент, если текущий не нулевой
				//j--;
				break;
			}
		} else { // если сумма элементов больше k, то необходимо сумму уменьшить (это возможно только взятием предыдущего элемента из второго массива)
			if (j > 0) { // перейти на следующий элемент, если текущий не нулевой
				j--;				
			} else if (i < len1 - 1) { // перейти на следующий элемент, если текущий не последний
				//i++;
				break;
			}
		}
		step_counter++;
	}

	return count;
}

int main() {
	
	// заполнение первого массива
	long len1 = 0;
	std::cin >> len1;
	int* series_1 = new int[len1];
	for (long i = 0; i < len1; i++) {
		std::cin >> series_1[i];
	}

	// заполнение второго массива
	long len2 = 0;
	std::cin >> len2;
	int* series_2 = new int[len2];
	for (long j = 0; j < len2; j++) {
		std::cin >> series_2[j];
	}

	long k = 0;
	std::cin >> k;

	std::cout << sumsEqualsTo( series_1, series_2, len1, len2, k) << std::endl;
	delete[] series_1;
	delete[] series_2;
	return 0;
}
